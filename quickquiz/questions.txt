1. Czym jest wzorzec projektowy "Proxy"?
a. Proxy to wzorzec projektowy, który pozwala na tworzenie obiektów poprzez kopiowanie istniejących instancji.
b. Proxy to wzorzec projektowy, który dostarcza zastępczy obiekt, kontrolujący dostęp do innego obiektu.
c. Proxy to wzorzec projektowy, który pozwala na dynamiczne tworzenie nowych klas.
d. Proxy to wzorzec projektowy, który umożliwia zaplanowanie czasochłonnych operacji na później.
-b

2. Jak zaimplementować wzorzec "Composite"?
a. Przechowując w każdym komponencie referencje na poprzedni i następny element struktury, by móc delegować do nich żądania.
b. Przechowując w każdym kompozycie referencję na nadrzędny komponent, by delegować do niego żądania, w razie potrzeby modyfikując je.
c. Tworząc wspólny interfejs dla komponentów, implementując Liście i Kompozyty, które realizują ten interfejs.
d. Tworząc klasę bazową, która implementuje wszystkie metody komponentów, a następnie dziedzicząc po niej.
-c

3. Jakie są zalety stosowania wzorca "Template Method"?
a. Ułatwia ponowne wykorzystanie kodu, wymagając nadpisania jedynie fragmentów dużego algorytmu.
b. Zwiększa elastyczność, umożliwiając wymianę algorytmu w zależności od zmieniającego się stanu obiektu.
c. Zmniejsza zużycie procesora, eliminując konieczność wielokrotnego wywoływania tego samego kodu.
d. Poprawia modularność, pozwalając na dynamiczną zmianę algorytmu zależnie od kontekstu.
-a

4. W jakich sytuacjach warto stosować wzorzec "Command"?
a. Gdy chcemy by obiekty systemu były w stanie wykonywać operacje na innych obiektach systemu.
b. Gdy chcemy by rozmaite komponenty systemu był informowane o działaniach jednego z nich.
c. Gdy chcemy aby komponenty tworzonące podsystem same był w stanie odnaleźć spośród siebie wykonawcę operacji.
d. Gdy chcemy reprezentować działania przy pomocy obiektów, by móc je przechowywać poza obiektem którego dotyczą.
-d

5. W jakich sytuacjach warto stosować wzorzec "Flyweight"?
a. Gdy mamy dużą liczbę obiektów o podobnym zachowaniu, aby zmniejszyć liczbę klas.
b. Gdy mamy klasę o dużej liczbę metod, aby podzielić ją na mniejsze, bardziej zrozumiałe części.
c. Gdy mamy duży pamięciowo obiekt, aby podzielić go na łatwiej zarządzalne części.
d. Gdy mamy dużą liczbę obiektów o podobnym stanie, aby zmniejszyć zużycie pamięci.
-d

6. Jakie są różnice między wzorcem "Factory Method" a "Abstract Factory"?
a. Factory Method tworzy jeden typ obiektu, podczas gdy Abstract Factory tworzy rodziny powiązanych obiektów.
b. Factory Method tworzy obiekty przy pomocy konstruktora, a Abstract Factory poprzez kopiowanie istniejących obiektów.
c. Asbtract Factory tworzy jedynie proste obiekty, podczas gdy Factory Method pozwala na tworzenie złożonych struktur.
d. Abstract Factory tworzy obiekt na podstawie parametrów wejściowych, a Factory Method na podstawie ustalonej konfiguracji.
-a

7. Jak działa wzorzec "Flyweight"?
a. Flyweight tworzy obiekty zawsze wtedy, gdy są one faktycznie potrzebne, aby zminimalizować złożoność czasową.
b. Flyweight tworzy obiekty tylko wtedy, gdy są one faktycznie potrzebne, aby zminimalizować zużycie pamięci.
c. Flyweight dzieli stan wewnętrzny obiektu na mniejsze części, które są tworzone i zarządzane niezależnie.
d. Flyweight rozdziela stan obiektu na zewnętrzny i wewnętrzny, umożliwiając współdzielenie obiektów o tym samym stanie.
-d

8. Jakie są wady stosowania wzorca "Adapter"?
a. Jego implementacja wymaga użycia metaklas, co może być trudne w niektórych językach programowania.
b. Nie posiada żadnych wad.
c. Może zwiększać złożoność kodu poprzez dodanie dodatkowej warstwy pośredniczącej.
d. Nie mamy pewności, czy nasze żądania znajdą odpowiedniego odbiorcę.
-c

9. Jak działa wzorzec "Template Method"?
a. Metoda szablonowa definiuje algorytm, wywołując metody abstrakcyjne lub wirtualne implementowane w klasach pochodnych.
b. Metoda szablonowa definiuje zależności pomiędzy komponentami systemu realizującymi poszczególne kroki algorytmu.
c. Metoda szablonowa definiuje strukturę algorytm, składając go z obiektów reprezentujących poszczególne kroki.
d. Metoda szablonowa definiuje pojedynczy krok algorytmu, pozostałą część zadania delegując do swego następnika.
-a

10. Czym jest wzorzec projektowy "Flyweight"?
a. Flyweight to wzorzec projektowy, który minimalizuje złożoność czasową poprzez wczesną inicjalizację odpowiedniej liczby obiektów.
b. Flyweight to wzorzec projektowy, który minimalizuje zużycie pamięci poprzez umożliwienie współdzielenia obiektów.
c. Flyweight to wzorzec projektowy, który minimalizuje zużycie pamięci poprzez umożliwienie ponownego wykorzystania zwolnionych obiektów.
d. Flyweight to wzorzec projektowy, który minimalizuje złożoność czasową poprzez leniwą inicjalizację obiektów.
-b

11. Jak działa wzorzec "Chain of Responsibility"?
a. Żądanie jest przekazywane wzdłuż łańcucha obiektów, a każdy obiekt je obsługuje i przekazuje dalej.
b. Łańcuch żądań jest przekazywany do obiektu, który decyduje, które z nich obsłużyć, a które odrzucić.
c. Żądania są sekwencyjnie przekazywane od obiektu, a te nieobsłużone trafiają na kolejkę, by być obsłużone później.
d. Żądanie jest przekazywane wzdłuż łańcucha obiektów, a każdy obiekt decyduje, czy je obsłużyć, czy przekazać dalej.
-d

12. W jakich sytuacjach warto używać wzorca "Proxy"?
a. Gdy obiekt docelowy ma interfejs niekompatybilny z resztą aplikacji.
b. Gdy chcemy delegować zadania do elementów systemu, ale nie wiemy których.
c. Gdy obiekt docelowy jest kosztowny w tworzeniu lub wymaga kontroli dostępu.
d. Gdy chcemy dynamicznie zmieniać zachowanie obiektu docelowego.
-c

13. Jak zaimplementować wzorzec "Chain of Responsibility"?
a. Każdy odbiorca powinien posiadać referencję do następnego odbiorcy, do którego przekaże żądanie, jeśli nie jest w stanie go obsłużyć.
b. Każdy odbiorca powinien posiadać referencję do obiektu, który przekazał mu żądanie, aby móc mu je odesłać, jeśli nie jest w stanie go obsłużyć.
c. Każdy odbiorca powinien posiadać listę referencji do komponentów, które zajmą się faktyczną obsługą żądania, a on zagreguje ich wyniki.
d. Każdy odbiorca powinien posiadać referencję do obiektu nadzorującego, by móc przekazać mu informację czy żądanie zostało obsłużone, czy nie.
-a

14. Jak wygląda relacja między Director a Builder w tym wzorcu?
a. Builder konstruuje obiekt, oddelegowując do Directora decyzje dotyczące sposobu jego reprezentacji.
b. Builder konstruuje obiekt, oddelegowując do Directora decyzje dotyczące jego struktury.
c. Builder odpowiada za stworzenie obiektu, a Director za dodanie mu funkcjonalności.
d. Director zarządza procesem konstrukcji, wykorzystując Builder do stworzenia obiektu.
-d

15. Czym jest wzorzec projektowy "Facade"?
a. Facade to wzorzec projektowy, który dostarcza uproszczony interfejs do bardziej złożonego systemu lub zestawu klas.
b. Facade to wzorzec projektowy, który umożliwia zaplanowanie czasochłonnych operacji na później.
c. Facade to wzorzec projektowy, który ujednolica interfejs dostępu do prostych i złożonych obiektów.
d. Facade to wzorzec projektowy, który pozwala na tworzenie obiektów poprzez kopiowanie istniejących instancji.
-a

16. Jak wzorzec "Prototype" wspiera zasadę SOLID "Open/Closed Principle"?
a. Pozwala na rozszerzanie obiektów o nowe funkcjonalności bez konieczności zmiany ich implementacji.
b. Pozwala na rozszerzanie aplikacji o nowe typy obiektów bez modyfikacji istniejącego kodu.
c. Pozwala na tworzenie obiektów otwartych na żądania, ale zamkniętych na modyfikowanie stanu.
d. Pozwala na tworzenie obiektów, które mogą być w przyszłości zastąpione innymi obiektami.
-b

17. Jak zaimplementować wzorzec "Flyweight"?
a. Identyfikując części wspólne obiektów i pozostawiając w nich, a różnice przenosząc do zewnętrznej struktury.
b. Identyfikując części wspólne obiektów i przenosząc je do zewnętrznej struktury, a różne pozostawiając w obiektach.
c. Tworząc klasę bazową, która implementuje wspólne metody, a następnie dziedzicząc po niej.
d. Tworząc klasę, która implementuje wspólne metody, a następnie delegując do niej operacje z pojeynczych obiektów.
-a

18. Jak zaimplementować wzorzec "Command"?
a. Dodając poza swoją klasą stos przechowujący stan obiektu po wykonaniu każdego polecenia.
b. Deklarując interfejs z metodami reprezentującymi różne polecenia oraz konkretną klasę implementującą ten interfejs.
c. Deklarując interfejs z pojedynczą metodą uruchamiającą oraz klasy implementujące ten interfejs, reprezentujące konkretne polecenia.
d. Deklarując interfejs z metodami Undo i Redo, a następnie implementując go w swojej klasie.
-c

19. W jakich sytuacjach warto stosować wzorzec "Facade"?
a. Gdy chcemy zastąpić istniejące obiekty nowymi, ale zachowując ich funkcjonalności.
b. Gdy chcemy zastąpić wiele klas o podobnym zachowaniu jedną, bardziej konfigurowalną klasą.
c. Gdy chcemy uprościć złożony system i zapewnić jednolity punkt dostępu do niego.
d. Gdy chcemy uniknąć tworzenia wielu klas pochodnych, które różnią się tylko implementacją.
-c

20. Czym jest wzorzec projektowy "Memento"?
a. Memento to wzorzec projektowy pozwalający na zatrzymywanie i wznawanie wykonywania operacji na obiekcie w zależności od dostępności zasobów.
b. Memento to wzorzec projektowy pozwalający obiektowi na powiadamianie innych obiektów o zmianie swojego stanu wewnętrznego.
c. Memento to wzorzec projektowy pozwalający na ustalanie harmonogramu wykonywania operacji na obiekcie w zależności od jego stanu wewnętrznego.
d. Memento to wzorzec projektowy pozwalający na zapisywanie i przywracanie poprzednich stanów obiektu bez naruszania jego enkapsulacji.
-d

21. Jak wzorzec "Memento" wspiera zasadę SOLID "Single Responsibility Principle"?
a. Oddziela odpowiedzialność za zachowanie stanu od jego przywracania.
b. Oddziela odpowiedzialność za przechowywanie stanu od logiki biznesowej.
c. Oddziela odpowiedzialność za realizację operacji od modyfikacji stanu.
d. Oddziela odpowiedzialność za obsługę żądania od jego wykonania.
-b

22. Czym jest wzorzec projektowy "Factory Method"?
a. Factory Method to wzorzec, który definiuje metodę do tworzenia obiektów, pozwalając podklasom decydować o ich typie.
b. Factory Method to wzorzec, który definiuje szkielet algorytmu, pozwalając podklasom na zmianę poszczególnych kroków.
c. Factory Method to wzorzec, który dostarcza interfejs do tworzenia złożonych obiektów krok po kroku.
d. Factory Method to wzorzec, który dostarcza zastępnik, który może być używany zamiast oryginalnego obiektu.
-a

23. Jak zaimplementować wzorzec "State"?
a. Tworząc klasę stanu, interfejs kontekstu i klasy reprezentujące różne konteksty.
b. Tworząc klasę stanu, której interfejs zawiera metody reprezentujące różne konteksty.
c. Tworząc klasę kontekstu, interfejs stanu i klasy reprezentujące różne stany.
d. Tworząc klasę kontekstu, której interfejs zawiera metody reprezentujące różne stany.
-c

24. Czym jest wzorzec projektowy "Bridge"?
a. Bridge to wzorzec projektowy, który zapewnia interakcję między komponentami systemu przez obiekt pośredniczący.
b. Bridge to wzorzec projektowy, który zapewnia bezpośrednią interakcję między komponentami systemu.
c. Bridge to wzorzec projektowy, który łączy abstrakcję z implementacją w jednej hierarchii klas.
d. Bridge to wzorzec projektowy, który oddziela abstrakcję od implementacji, pozwalając na ich niezależny rozwój.
-d

25. W jakich sytuacjach warto stosować wzorzec "Bridge"?
a. Gdy chcemy konstruować złożone obiekty krok po kroku.
b. Gdy chcemy uniknąć tworzenia wielu klas pochodnych, które różnią się tylko implementacją.
c. Gdy chcemy zapobiec tworzeniu nadmiarowych instancji obiektów.
d. Gdy chcemy wykonać pewne działanie na wszystkich obiektach złożonej struktury.
-b

26. Czym jest wzorzec projektowy "Abstract Factory"?
a. Abstract Factory to wzorzec projektowy, który pozwala na tworzenie obiektów poprzez kopiowanie istniejących instancji.
b. Asbtract Factory to wzorzec projektowy, który umożliwia tworzenie obiektów poprzez podanie algorytmu ich konstrukcji.
c. Abstract Factory to wzorzec projektowy, który tworzy zastępniki produktów, które mogą być używane do momentu utworzenia właściwych obiektów.
d. Abstract Factory to wzorzec projektowy, który dostarcza interfejs do tworzenia rodzin powiązanych lub zależnych obiektów bez określania ich konkretnych klas.
-d

27. Czym jest wzorzec projektowy "Command"?
a. Command to wzorzec projektowy definiujący żądanie w klasie bazowej, jej implementację pozostawiający klasom pochodnym.
b. Command to wzorzec projektowy, który zamienia żądania w obiekty, pozwalając na ich parametryzację, przechowywanie i logowanie.
c. Command to wzorzec projektowy pozwalający na przekazywanie żądań przez sekwencję obiektów, aż któryś z nich obsłuży to żądanie.
d. Command to wzorzec projektowy, który pozwala na tworzenie obiektów na żądanie, zamiast tworzenia ich na stałe.
-b

28. Jak działa wzorzec "Memento"?
a. Klasa, której stan chcemy zachować, odpowiada za stworzenie Memento i przywrócenie stanu na jego podstawie.
b. Klasa, której stan chcemy zachować, odpowiada za wykonanie swojej kopii, która będzie przechowywana w Memento.
c. Klasa, której stan chcemy zachować, deleguje zapisywanie i przywracanie stanu do Memento.
d. Klasa, której stan chcemy zachować, udostępnia metody do zapisywania i przywracania stanu, które są wywoływane przez Memento.
-a

29. W jakich sytuacjach warto stosować wzorzec "Strategy"?
a. Gdy chcemy reprezentować algorytmy w postaci drzewiastej struktury, by móc przebudowywać je w czasie działania aplikacji.
b. Gdy chcemy wyizolować złożone zależności i interakcje między komponentami systemu i zarządzać nimi centralnie.
c. Gdy wiele algorytmów może być stosowanych zamiennie i wybór algorytmu powinien być możliwy w czasie działania aplikacji.
d. Gdy ogólny kształt algorytmu jest znany i niezmienny, ale szczegóły implementacji mogą się różnić zależnie od kontekstu.
-c

30. W jakich sytuacjach warto stosować wzorzec "Chain of Responsibility"?
a. Gdy chcemy umożliwić modyfikację żądania w locie, zanim zostanie ono obsłużone.
b. Gdy chcemy umożliwić przesłanie jednego żądania do wielu obiektów jednocześnie.
c. Gdy chcemy umożliwić wielu obiektom obsługę żądania, ale nie wiemy, który z nich to zrobi.
d. Gdy chcemy umożliwić obiektowi buforowanie żądań, zanim zostaną one obsłużone.
-c

31. Jakie są zalety stosowania wzorca "Mediator"?
a. Poprawia bezpieczeństwo aplikacji poprzez stworzenie hierarchicznej struktury odpowiedzialności.
b. Zmniejsza liczbę zależności między komponentami, co ułatwia ich testowanie i rozszerzanie.
c. Poprawia wydajność aplikacji poprzez zmniejszenie liczby komponentów systemu.
d. Zwiększa zależność między komponentami, co prowadzi do lepszej integracji systemu.
-b

32. Jakie są typowe zastosowania wzorca "Command"?
a. Potokowe przetwarzanie danych strumieniowych.
b. Filtrowanie lub sortowanie sekwencji obiektów.
c. Buforowanie lub cache'owanie danych.
d. Kolejkowanie, składowanie i harmonogramowanie zadań.
-d

33. W jakich sytuacjach warto stosować wzorzec "Adapter"?
a. Gdy interakcje pomiędzy komponentami są zbyt skomplikowane do zarządzania bez dodatkowej warstwy abstrakcji.
b. Gdy chcemy poszerzyć funkcjonaność obiektu o nowe metody.
c. Gdy istnieją klasy z niezgodnymi interfejsami, które muszą współpracować.
d. Gdy chcemy zmodyfikować funkcjonalość obiektu, zachowując pierwotny interfejs.
-c

34. W jakich sytuacjach warto stosować wzorzec "Composite"?
a. Gdy chcemy zastąpić istniejące obiekty nowymi, ale zachowując ich funkcjonalności.
b. Gdy chcemy reprezentować hierarchie obiektów i umożliwić ich jednolite traktowanie.
c. Gdy chcemy reprezentować zależność typu jeden-do-wielu między obiektami.
d. Gdy potrzebujemy sekwencyjnego dostępu do poszczeólnych elementów struktury.
-b

35. Czym jest wzorzec projektowy "Iterator"?
a. Iterator to wzorzec projektowy, który pozwala na skierowanie sekwencji żądań do pojedynczego elementu struktury bez ujawniania jej implementacji.
b. Iterator to wzorzec projektowy, który pozwala na skierowanie pojedynczego żądania do wszystkich elementów kolekcji bez ujawniania jej wewnętrznej struktury.
c. Iterator to wzorzec projektowy, który umożliwia sekwencyjne przeglądanie elementów kolekcji bez ujawniania jej wewnętrznej reprezentacji.
d. Iterator to wzorzec projektowy, który umożliwia delegowanie żądań kierowanych do struktury, dopóki nie zostaną one przez któryś z nich zrealizowane.
-c

36. Jak zaimplementować wzorzec "Abstract Factory"?
a. Tworząc interfejs fabryki oraz klasy konkretne implementujące ten interfejs dla każdej rodziny produktów.
b. Łącząc niepowiązane ze sobą hierarchie produktów za pomocą wspólnej klasy bazowej.
c. Deklarując klasę statyczną, która tworzy obiekty na podstawie parametrów wejściowych.
d. Definiując interfejs fabryki, który musi zostać zaimplementowany przez każdy rodzaj produktu.
-a

37. Jakie są różnice między wzorcem "State" a wzorcem "Strategy"?
a. Wzorzec "State" zmienia zachowanie obiektu w zależności od jego wewnętrznego stanu, a wzorzec "Strategy" pozwala na wybór odbiorcy do realizacji żądania.
b. Wzorzec "State" zmienia stan obiektu w zależności od kierowanego do niego żądania, a wzorzec "Strategy" pozwala na wybór odbiorcy do realizacji żądania.
c. Wzorzec "State" zmienia zachowanie obiektu w zależności od jego wewnętrznego stanu, a wzorzec "Strategy" pozwala na wybór algorytmu w czasie działania aplikacji.
d. Wzorzec "State" zmienia stan obiektu w zależności od kierowanego do niego żądania, a wzorzec "Strategy" pozwala na wybór algorytmu w czasie działania aplikacji.
-c

38. Czym jest wzorzec projektowy "Builder"?
a. Builder to wzorzec projektowy, który pozwala na uzupełnianie obiektów o nowe funkcjonalności w trakcie działania programu.
b. Builder to wzorzec projektowy, który pozwala na tworzenie obiektów poprzez kopiowanie istniejących instancji.
c. Builder to wzorzec projektowy, który oddziela proces konstrukcji złożonego obiektu od jego reprezentacji.
d. Builder to wzorzec projektowy, który definiuje szkielet obiektu, pozwalając na rozbudowanie go później.
-c

39. Czym jest wzorzec projektowy "Chain of Responsibility"?
a. Chain of Responsibility to wzorzec projektowy pozwalający na przekazanie żądania do sekwencji obiektów, aż każdy z nich je obsłuży.
b. Chain of Responsibility to wzorzec projektowy pozwalający na przekazanie sekwencji żądań do obiektu, aż każde z nich zostanie obsłużone.
c. Chain of Responsibility to wzorzec projektowy pozwalający na przekazanie żądania przez sekwencję obiektów, aż któryś z nich je obsłuży.
d. Chain of Responsibility to wzorzec projektowy pozwalający na ponawianiu żądania przekazanego do obiektu, aż zostanie ono poprawnie obsłużone.
-c

40. Czym jest wzorzec projektowy "State"?
a. State to wzorzec projektowy pozwalający na współdzielenie obiektów o identycznym stanie wewenętrznym.
b. State to wzorzec projektowy umożliwiający obiektowi zmianę zachowania w zależności od jego wewnętrznego stanu.
c. State to wzorzec projektowy, który umożliwia automatyczne powiadamianie obiektów o zmianie stanu innego obiektu.
d. State to wzorzec projektowy pozwalający na zapisywanie i przywracanie poprzednich stanów obiektu.
-b

41. Czym jest wzorzec projektowy "Singleton"?
a. Singleton to wzorzec, który umożliwia komunikację między obiektami, poprzez centralizację interakcji.
b. Singleton to wzorzec, który pozwala na dodawanie nowych operacji do już istniejących obiektów.
c. Singleton to wzorzec, który zapewnia, że dana klasa ma tylko jedną instancję w całej aplikacji.
d. Singleton to wzorzec, który dostarcza uproszczony interfejs do złożonego systemu.
-c

42. Jak zaimplementować wzorzec "Factory Method"?
a. Deklarując klasę bazową, która tworzy obiekty na podstawie parametrów wejściowych.
b. Definiując w klasie produktu metodę, która zwraca jego głęboką kopię.
c. Definiując w klasie bazowej metodę, która zwraca obiekt, a jej implementację dostarczają klasy pochodne.
d. Deklarując interfejs fabryki, który musi być zaimplementowany przez wszystkie klasy fabryk.
-c

43. Jakie są zalety stosowania wzorca "Visitor"?
a. Umożliwia łatwe dodawanie nowych elementów struktury bez zmiany istniejących Visitorów.
b. Umożliwia łatwe dodawanie nowych operacji bez zmiany istniejącego kodu.
c. Poprawia wydajność, eliminując konieczność wielokrotnego wywoływania tej samej metody.
d. Zmniejsza liczbę klas w systemie, eliminując konieczność dziedziczenia.
-b

44. Jak działa wzorzec "Adapter"?
a. Adapter zastępuje obiekt docelowy w prostszych operacjach, ale przekazuje bardziej złożone do niego.
b. Adapter tłumaczy żądania klienta na operacje zgodne z interfejsem obiektu docelowego.
c. Adapter odbiera żądania od klienta, ale sam decyduje kiedy przekazać je do obiektu docelowego.
d. Adapter decyduje do któego z obiektów docelowych przekazać żądanie klienta.
-b

45. W jakich sytuacjach warto stosować wzorzec "Builder"?
a. Gdy wymagane jest ograniczenie liczby instancji danej klasy w aplikacji.
b. Gdy musimy stworzyć wiele podobnych do siebie obiektów, ale z różnymi parametrami.
c. Gdy konieczne jest tworzenie złożonych obiektów, których proces konstrukcji wymaga wielu etapów lub kroków.
d. Gdy chcemy zastąpić istniejące obiekty nowymi, ale zachowując ich funkcjonalności.
-c

46. Czym jest wzorzec projektowy "Adapter"?
a. Adapter to wzorzec projektowy, który zapewnia uproszczony interfejs dostępu do złożonego podsystemu.
b. Adapter to wzorzec projektowy, który zmienia zachowanie obiektu w zależności od jego stanu wewnętrznego.
c. Adapter to wzorzec projektowy, który umożliwia łączenie wielu obiektów w jedną, bardziej złożoną strukturę.
d. Adapter to wzorzec projektowy, który pozwala na współpracę klas o niezgodnych interfejsach poprzez stworzenie klasy pośredniczącej.
-d

47. Jakie metody powinien oferować Iterator?
a. Metodę dodania nowego elementu do kolekcji i usunięcia istniejącego.
b. Metodę sprawdzenia czy kolekcja jest pusta i pobrania pierwszego elementu.
c. Metodę pobrania następnego elementu i sprawdzenia czy kolejny element istnieje.
d. Metodę sprawdzenia liczby elementów i pobrania elementu o podanym indeksie.
-c

48. W jakich sytuacjach warto stosować wzorzec "Memento"?
a. Gdy potrzebujemy otrzymać powiadomienie o zmianie stanu obiektu.
b. Gdy potrzebujemy odłożyć wykonanie operacji na obiekcie na później.
c. Gdy potrzebujemy cofnąć obiekt do poprzedniego stanu lub zapamiętać jego historię.
d. Gdy potrzebujemy delegować obsługę żądania do innego obiektu.
-c

49. Jakie są wady stosowania wzorca "Chain of Responsibility"?
a. Istnieje ryzyko, że żądanie nie zostanie obsłużone przez żadnego z odbiorców.
b. Istnieje ryzyko, że odbiorca otrzyma jednocześnie kilka żądań i nie będzie wiedział w jakiej kolejności je obsłużyć.
c. Istnieje ryzyko, że kilku odbiorców będzie przekazywać sobie żądanie w nieskończoność.
d. Istnieje ryzyko, że kilku odbiorców obsługujących to samo żądanie zacznie jednocześnie modyfikować wspólne dane.
-a

50. Czym jest wzorzec projektowy "Decorator"?
a. Wzorzec "Decorator" pozwala na statyczne dodawanie nowych funkcji do obiektów poprzez dziedziczenie.
b. Wzorzec "Decorator" pozwala na dynamiczne dodawanie nowych funkcji do obiektów bez zmiany ich kodu źródłowego.
c. Wzorzec "Decorator" pozwala na tworzenie nowych obiektów na podstawie istniejących, ale z innymi parametrami.
d. Wzorzec "Decorator" pozwala na tworzenie nowych obiektów poprzez kopiowanie istniejących obiektów.
-b

51. Jakie są kluczowe cechy wzorca "Singleton"?
a. Zapewnienie jednego interfejsu dla wielu niepowiązanych ze sobą klas.
b. Zapewnienie, że metody klasy będą wykonywane w określonej kolejności.
c. Zablokowanie możliwości zmiany stanu obiektu po jego utworzeniu.
d. Zapewnienie istnienia jednej instancji klasy oraz globalny dostęp do niej.
-d

52. Jak wzorzec "Decorator" działa w porównaniu z wzorcem "Proxy"?
a. Dekorator dodaje funkcjonalność, a Proxy kontroluje dostęp do obiektu.
b. Dekorator znajduje się na zwenątrz, a Proxy wewnątrz obiektu.
c. Dekorator zachowuje, a Proxy zmienia interfejs obiektu.
d. Dekoratory można łączyć dzieki dziedziczeniu, a Proxy dzięki kompozycji.
-a

53. W jakich sytuacjach warto stosować wzorzec "Singleton"?
a. Gdy potrzebna jest globalna kontrola dostępu do zasobu.
b. Gdy aplikacja wymaga tylko jednej klasy bazowej.
c. Gdy potrzebny jest interfejs do złożonego systemu, który ukrywa jego implementację.
d. Gdy potrzebne są obiekty, które można tworzyć dynamicznie w zależności od kontekstu.
-a

54. W jakich sytuacjach warto stosować wzorzec "Observer"?
a. Gdy chcemy wykonywać pewne działanie na wszystkich elementach złożonej struktury.
b. Gdy żądanie kierowane do jednego obiektu powinno być automatycznie przekazywane do innego.
c. Gdy wiele obiektów ma identyczny stan i chcemy go między nimi współdzielić.
d. Gdy zmiana stanu jednego obiektu wymaga powiadomienia wielu innych obiektów.
-d

55. W jakich sytuacjach warto stosować wzorzec "Mediator"?
a. Gdy chcemy w przeźroczysty sposób modyfikować komunikację między komponentami systemu.
b. Gdy chcemy wykorzystać komponenty, których interfejsy nie są zgodne z resztą programu.
c. Gdy liczba zależności między komponentami systemu jest zbyt duża i trudna do zarządzania.
d. Gdy liczba komponentów staje się zbyt duża, by zarządzać ich komunikacją w jednym miejscu.
-c

56. Jakie są zalety stosowania wzorca "Flyweight"?
a. Zmniejsza złożoność systemu przez dodanie warstwy zarządzania stanem aplikacji.
b. Zmniejsza złożoność czasową poprzez leniwą inicjalizację obiektów.
c. Zmniejsza zużycie pamięci przez współdzielenie obiektów.
d. Zmniejsza odpowiedzialność programisty przez automatyzację zwalniania pamięci.
-c

57. Jakie są wady stosowania wzorca "Observer"?
a. Może prowadzić do problemów z wydajnością w przypadku dużej liczby obserwatorów lub częstych powiadomień.
b. Dodawanie i usuwanie obserwatorów w czasie działania programu może być skomplikowane i prowadzić do błędów.
c. Może być niewystarczające w pewnych systemach z powodu ograniczenia do jednego obiektu obserwowanego.
d. Trudne jest dodawanie nowych typów obserwatorów i nowych typów obiektów obserwowanych.
-a

58. Jakie są zalety stosowania wzorca "State"?
a. Unikamy konieczności cyklicznego sprawdzania stanu obiektu, by wybrać odpowiednią logikę.
b. Unikamy konieczności przechowywania wielu kopii obiektu o różnych stanach.
c. Unikamy złożonych instrukcji warunkowych, które wybierałyby logikę w zależności od stanu obiektu.
d. Unikamy nadmiernie rozbudowanej hierarchii klas, które reprezentowałyby różne stany obiektu.
-c

59. Jak zaimplementować wzorzec "Proxy"?
a. Proxy zawiera pojedynczą metodę dajacą dostęp do wszystkich funkcjonalnosci rzeczywistego obiektu na podstawie parametru wejściowego.
b. Proxy dziedziczy po rzeczywistym obiekcie, w razie potrzeby nadpisując jego metody.
c. Proxy implementuje ten sam interfejs, co rzeczywisty obiekt, i deleguje do niego operacje.
d. Proxy zawiera kolekcję rzeczywistych obiektów, które są używane naprzemiennie lub w zależności od kontekstu.
-c

60. Jak działa wzorzec "Facade"?
a. Facade dostarcza uproszczony interfejs, który deleguje żądania do odpowiednich komponentów systemu podrzędnego.
b. Facade reprezentuje żądania w postaci obiektów, które następnie są przekazywane do komponentów systemu.
c. Facade dziedziczy po wszystkich komponentach systemu, aby ułatwić dostęp do ich funkcjonalności.
d. Facade definiuje interfejs, który jest implementowany przez wszystkie komponenty systemu.
-a

61. Jakie są zalety stosowania wzorca "Bridge"?
a. Umożliwia oddzielenie żądań od ich wykonania.
b. Umożliwia niezależny rozwój abstrakcji i implementacji.
c. Redukuje liczbę wzajemnych zależności pomiędzy komponentami systemu.
d. Ujednolica dostęp do elementów złożonego systemu.
-b

62. Jakie są zalety stosowania wzorca "Command"?
a. Zwiększa bezpieczeństwo automatyzując walidację danych wejściowych.
b. Oddziela obiekt wykonujący operację od obiektu inicjującego operację.
c. Umożliwia zatrzymanie i wznowienie wykonywania operacji.
d. Centralizuje logikę obsługi żądań w jednym miejscu.
-b

63. Jak działa wzorzec "Bridge"?
a. Deleguje żądania między komponentami systemu przez obiekt pośredniczący.
b. Definiuje metody, które mogą być używane przez inne klasy.
c. Oddziela abstrakcję od implementacji, umożliwiając ich niezależne zmiany.
d. Dostarcza uproszczony interfejs do bardziej złożonego systemu.
-c

64. Jakie są wady stosowania wzorca "Mediator"?
a. Może prowadzić do nadmiernego rozrastania się klasy Mediator, która centralizuje całą logikę komunikacji.
b. Śledzenie stanu wszystkich komponentów przez Mediatora może prowadzić do nadmiernego zużycia pamięci.
c. Mediator musi mieć dostęp do prywatnych metod komponentów, co narusza zasadę enkapsulacji.
d. Mediator nie ma kontroli nad tym w jakim czasie ani w jakiej kolejności komponenty będą odbierać jego komunikaty.
-a

65. Czym jest wzorzec projektowy "Visitor"?
a. Visitor to wzorzec projektowy pozwalający na zmienianie i przywracanie stanu obiektu bez naruszania jego enkapsulacji.
b. Visitor to wzorzec projektowy, który pozwala na przekazywanie żądań przez sekwencję obiektów, aż któryś z nich je obsłuży.
c. Visitor to wzorzec projektowy, który pozwala na automatyczne powiadamianie wielu obiektów o zmianach stanu innego obiektu.
d. Visitor to wzorzec projektowy umożliwiający dodawanie nowych operacji do istniejących struktur obiektowych bez zmieniania ich kodu.
-d

66. Jak działa wzorzec "Strategy"?
a. Obiekt kontekstu deleguje wykonywanie algorytmu do metody realizującej konkretną strategię.
b. Obiekt kontekstu definiuje ogólny algorytm strategii, którego każdy krok może być zmieniony na podstawie parametrów.
c. Obiekt kontekstu deleguje wykonywanie algorytmu do obiektu reprezentującego konkretną strategię.
d. Obiekt kontekstu definiuje sposób realizacji kroków strategii, której szczegółowy algorytm zostanie zdefiniowany w klasie pochodnej.
-c

67. Jak działa wzorzec "Observer"?
a. Stan obserwatora i obiektu obserwowanego są powiązane i zmieniają się równocześnie.
b. Obserwator cyklicznie sprawdza stan obiektu obserwowanego i reaguje na zmiany.
c. Obiekt obserwowany informuje zarejestrowanych obserwatorów o zmianach swojego stanu.
d. Obserwator przechwytuje żądania skierowane do obiektu obserwowanego, co daje mu pełną kontrolę nad jego stanem.
-c

68. W jakich sytuacjach warto stosować wzorzec "Iterator"?
a. Gdy konieczne jest iterowanie po elementach kolekcji w sposób niezależny od jej implementacji.
b. Gdy konieczne jest modifikowanie struktury kolekcji bez konieczności przerwania iteracji.
c. Gdy chcemy zaimplementować iterację w języku, który nie oferuje wbudowanych mechanizmów iteracji.
d. Gdy chcemy wykonać operację na elementach kolekcji bez ręcznego iterowania po nich.
-a

69. Jakie są zalety stosowania wzorca "Facade"?
a. Umożliwia niezależny rozwój abstrakcji i implementacji.
b. Zapewnia luźne powiązanie między komponentami systemu.
c. Redukuje zależności między klientem a komponentami systemu.
d. Pozwala na zachowanie stanu obiektu między kolejnymi żądaniami.
-c

70. Jakie są potencjalne zagrożenia przy stosowaniu wzorca "Memento"?
a. Jeśli operacja nie jest odwracalna, przywrócenie stanu może nie być możliwe.
b. Przechowywanie dużej liczby stanów może prowadzić do wyczerpania zasobów pamięci.
c. Równoległe przetważanie żądań może prowadzić do konfliktów w dostępie do stanu.
d. Istnieje ryzyko, że zakolejkowane żądania nie zostaną nigdy obsłużone.
-b

71. Jakie są potencjalne problemy związane z używaniem wzorca "Prototype"?
a. Dodanie nowych rodzajów produktów jest trudne i wymaga modyfikacji istniejącego kodu.
b. Stworzone obiekty mogą być w niektórych sytuacjach niewystarczające do działania aplikacji.
c. Nie mamy gwarancji poprawnego zainicjalizowania tworzonego obiektów.
d. Może prowadzić do trudności w klonowaniu złożonych obiektów z odwołaniami do innych obiektów.
-d

72. W jakich sytuacjach warto stosować wzorzec "Template Method"?
a. Gdy wiele klas może zrealizować ten sam algorytm i chcemy dynamicznie wybierać implementację.
b. Gdy wiele klas współpracuje w realizacji tego samego algorytmu i chcemy ukryć te szczeóły przed klientem.
c. Gdy wiele klas implementuje podobny algorytm, ale z niewielkimi różnicami w szczegółach.
d. Gdy wiele klas powinno móc jednocześnie wykonywać ten sam algorytm, ale w różnych kontekstach.
-c

73. W jakich sytuacjach warto stosować wzorzec "Visitor"?
a. Gdy komponenty systemu powinny być informowane o zmianach w innych komponentach.
b. Gdy chcemy dodawać nowe operacje do hierarchii klas bez ich modyfikacji.
c. Gdy żądania kierowane do jednego obiektu powinny być automatycznie przekazywane do innego.
d. Gdy często modyfikujemy hierarchię klas i chcemy zachować spójność kodu.
-b

74. Jakie są główne cele stosowania wzorca "Prototype"?
a. Korzystanie z uproszczonych implementacji obiektów na etapie testowania systemu.
b. Zmniejszenie kosztów tworzenia obiektów poprzez klonowanie istniejących instancji.
c. Tworzenie instancji, któych klasę można później zmienić.
d. Oszczędność pamięci poprzez współdzielenie zasobów między obiektami.
-b

75. Jak działa wzorzec "Composite"?
a. Composite organizuje obiekty w strukturę drzewa, umożliwiając traktowanie grup obiektów i pojedynczych elementów w ten sam sposób.
b. Composite gromadzi wszystkie elementy struktury w jednym miejscu i centralizuje logikę interakcji między nimi.
c. Composite nie ma własnego stanu ani logiki, opdpowiada jedynie za przekazywanie żądań do innych komponentów systemu.
d. Composite wykorzystuje kompozycję, aby dodawać nową funkcjonalność do istniejących obiektów.
-a

76. W jakich sytuacjach warto stosować wzorzec "State"?
a. Gdy wiele obiektów ma identyczny stan i chcemy go między nimi współdzielić.
b. Gdy zmiana stanu jednego obiektu powinna powodować automatyczną zmianę stanu innego.
c. Gdy obiekt może przyjmować jeden z wiele stanów, które wymagają różnych zachowań.
d. Gdy chcemy zachować aktualny stan obiektu by móc go później przywrócić.
-c

77. Jak wzorzec "Abstract Factory" wspiera zasadę SOLID "Open/Closed Principle"?
a. Pozwala na dodawanie nowych rodzin produktów bez zmiany istniejącego kodu.
b. Pozwala na czasowe zablokowanie możliwości tworzenia nowych obiektów.
c. Umożliwia tworzenie obiektów, których nie można modyfikować.
d. Zapobiega tworzeniu nadmiarowych instancji obiektów.
-a

78. Czym jest wzorzec projektowy "Template Method"?
a. Template Method to wzorzec projektowy definiujący składniki algorytmu w klasie bazowej, a jego konkretny przebieg w klasach pochodnych.
b. Template Method to wzorzec projektowy definiujący szkielet algorytmu w klasie bazowej, a szczegóły implementacji w klasach pochodnych.
c. Template Method to wzorzec projektowy definiujący algorytm, który zmienia się w czasie, w zależności od stanu obiektu.
d. Template Method to wzorzec projektowy definiujący mockowy wariant algorytmu, który może być używany w testach jednostkowych.
-b

79. Jak można zaimplementować wzorzec "Singleton"?
a. Przez wykorzystanie metod prywatnych, które uniemożliwiają tworzenie nowych instancji klasy.
b. Poprzez zastosowanie abstrakcyjnej klasy bazowej, która kontroluje dostęp do instancji klasy.
c. Przez zastosowanie statycznej metody, która zwraca instancję klasy, a jeśli nie istnieje, tworzy ją.
d. Poprzez rzucanie wyjątków w przypadku próby utworzenia więcej niż jednej instancji klasy.
-c

80. Jak wzorzec "Strategy" wpływa na strukturę kodu?
a. Zastępuje wywoływanie metod klasy bazowej delegowaniem żądań do klas pochodnych.
b. Zastępuje złożone instrukcje if-else lub switch dziedziczeniem.
c. Zastępuje rozbudowaną logikę klas pochodnych delegowaniem żądań do klasy bazowej.
d. Zastępuje złożoną hierarchię dziedziczenia instrukcjami if-else lub switch.
-a

81. W jakim celu stosuje się wzorzec "Proxy"?
a. W celu dynamicznego dodawania bądź usuwania funkcjonalności obiektu w trakcie działania programu.
b. W celu zmniejszenia liczby instancji obiektu w aplikacji poprzez jego współdzielenie.
c. W celu zastąpienia oryginalnego obiektu nowym, bardziej wydajnym lub opartym na innej technologii.
d. W celu kontrolowania dostępu do obiektu, zmniejszenia kosztów jego tworzenia lub zarządzania jego użyciem.
-d

82. Jakie są wady stosowania wzorca "Bridge"?
a. Jego implementacja może wymagać zaawansowanej logiki.
b. Wprowadza dodatkową warstwę abstrakcji, co może zwiększać złożoność kodu.
c. Nie możemy być pewni, czy nasze żądania znajdą odpowiedniego odbiorcę.
d. Opiera się na wielodziedziczeniu, co nie w każdym języku jest możliwe.
-b

83. Czym jest wzorzec projektowy "Composite"?
a. Composite to wzorzec projektowy, który dostarcza uproszczony interfejs dostępu do złożonego podsystemu.
b. Composite to wzorzec projektowy, który umożliwia traktowanie pojedynczych obiektów i ich grup w jednakowy sposób.
c. Composite to wzorzec projektowy, który oddziela proces tworzenia obiektów od ich reprezentacji.
d. Composite to wzorzec projektowy, który pozwala na centralizację zarządzania obiektami w jednym miejscu.
-b

84. Co odróżnia "konstruktor dekoratora" od standardowego konstruktora klasy?
a. Konstruktor dekoratora nie przyjmuje żadnych argumentów.
b. Konstruktor dekoratora jest zawsze statyczny.
c. Konstruktor dekoratora przyjmuje obiekt, który implementuje ten sam interfejs.
d. Konstruktor dekoratora jest zawsze prywatny.
-c

85. Jakie są wady stosowania wzorca "Template Method"?
a. Trudno jest przewidzieć w jakiej kolejności zostaną wykonane poszczególne kroki algorytmu.
b. Zdefiniowany szkielet algorytmu może stanowić ograniczenie dla niektórych klientów.
c. Częste redefiniowanie algorytmu zwiększa zużycie pamięci i obciążenie procesora.
d. Algorytm może zmienić się w trakcie wykonywania, co prowadzi do nieprzewidywalnych rezultatów.
-b

86. Jak działa wzorzec "Iterator"?
a. Umożliwia przekazanie do kolekcji pojedynczego żądania, które zostanie zrealizowane przez wszystkie elementy.
b. Zapewnia dostęp do wszystkich elementów kolekcji jednocześnie, bez konieczności ręcznego iterowania po nich.
c. Zapewnia sekwencyjny dostęp do elementów kolekcji, bez konieczności znajomości jej struktury wewnętrznej.
d. Umożliwia przekazywanie żądań przez sekwencję obiektów, aż któryś z nich je obsłuży lub odrzuci.
-c

87. Czym jest wzorzec projektowy "Mediator"?
a. Mediator to wzorzec projektowy, który łączy obiekty w hierarchiczną strukturę, dyktującą zasady ich komunikacji.
b. Mediator to wzorzec projektowy, który pozwala na automatyczne informowanie wielu obiektów o zmianach stanu innego obiektu.
c. Mediator to wzorzec projektowy, który centralizuje interakcję między obiektami w dedykowanym obiekcie pośredniczącym.
d. Mediator to wzorzec projektowy, który potrafi zmieniać zachowanie obiektów poprzez dodanie warstwy pośredniczącej.
-c

88. Jak wzorzec "Decorator" różni się od dziedziczenia?
a. Dekorator pozwala na dodawanie funkcjonalności w czasie działania, podczas gdy dziedziczenie wymaga zmian w czasie kompilacji.
b. Dekorator pozwala na zmianę funkcjonalności, podczas gdy dziedziczenie pozwala jedynie na zmianę reprezentacji.
c. Dekorator jest wydajniejszy od dziedziczenia pod względem zużycia pamięci i czasu procesora.
d. Dekorator pozwala na tworzenie nowych klas, podczas gdy dziedziczenie pozwala na tworzenie nowych obiektów.
-a

89. Jak działa wzorzec "Mediator"?
a. Centralizuje logikę komunikacji między komponentami, eliminując bezpośrednie zależności między nimi.
b. Decentralizuje logikę komunikacji między komponentami, umożliwiając im bezpośrednią interakcję.
c. Łączy komponenty w łańcuch, w którym każdy komponent może przekazać żądanie jedynie do następnego w łańcuchu.
d. Łączy komponenty w hierarchię, w której każdy komponent może komunikować się jedynie z poziomami o jeden wyżej lub niżej.
-a

90. Czym jest wzorzec projektowy "Observer"?
a. Observer to wzorzec projektowy, który definiuje warstwę pośredniczącą, modyfikującą żądania przesyłane między obiektami.
b. Observer to wzorzec projektowy, który umożliwia automatyczne powiadamianie wielu obiektów o zmianach stanu innego obiektu.
c. Observer to wzorzec projektowy, który centralizuje logikę komunikacji między obiektami w dedykowanym obiekcie pośredniczącym.
d. Observer to wzorzec projektowy, który umożliwia przekazywanie żądania przez sekwencję obiektów, aż jeden z nich je obsłuży.
-b

91. W jaki sposób dekoratory mogą być łączone?
a. Wielodziedziczenie pozwala na łączenie kilku dekoratorów w jednej klasie.
b. Każdy dekorator opakowuje obiekt, który może być kolejnym dekoratorem.
c. Każdy dekorator może być zaimplementowany jako osobna metoda w jednej klasie.
d. Obiekt przechowuje listę dekoratorów, które są wywoływane w odpowiedniej kolejności.
-b

92. Jak zaimplementować wzorzec "Builder"?
a. Tworząc klasę budowniczego, która definiuje metody konstruujące obiekt krok po kroku.
b. Towrząc klasę z szeregiem metod budujących, każda tworząca inny wariant obiektu.
c. Tworząc klasę z pojedynczą metodą budowniczego, która konstruuje obiekt zależnie od parametrów wejściowych.
d. Tworząc klasę, która potrafi odpytać użytkownika o parametry obiektu i na ich podstawie go skonstruować.
-a

93. Jakie są wady stosowania wzorca "Facade"?
a. Może prowadzić do nadmiernego wzrostu liczby klas w systemie.
b. Może naruszać hermetyzacją, przez ujawnianie zbyt wielu szczegółów implementacji.
c. Może prowadzić do nadmiernego zużycia pamięci w trakcie działania programu.
d. Może ukrywać zbyt wiele szczegółów, co utrudnia dostęp do pełnej funkcjonalności systemu.
-d

94. Jak zaimplementować wzorzec "Prototype"?
a. Implementując metodę delegującą żądania do klasy określonej na etapie wykonania programu.
b. Definiując klasę prototypową, która implementuje wymagany interfejs, ale bez rzeczywistej funkcjonalności i danych.
c. Definiując klasę fabryki prototypów, która tworzy obiekty na podstawie parametrów wejściowych.
d. Implementując metodę klonującą w klasie bazowej i używając jej w celu stworzenia kopii istniejących obiektów.
-d

95. Jakie są wady stosowania wzorca "Strategy"?
a. Trudność dodania nowych strategii.
b. Trudność wymiany strategii w czasie działania aplikacji.
c. Zwiększa liczbę instrukcji warunkowych w kodzie.
d. Zwiększa zależność między kontekstem a strategią.
-d

96. Jak wzorzec "Builder" różni się od wzorca "Factory Method"?
a. Builder opiera się na dziedziczeniu, a Factory Method na kompozycji.
b. Builder jest uproszczoną wersją Factory Method.
c. Builder koncentruje się na stopniowej konstrukcji złożonych obiektów, podczas gdy Factory Method tworzy obiekty w jednym kroku.
d. Builder skupia się na tworzeniu obiektów na podstawie parametrów wejściowych, a Factory Method na wyborze rodzaju obiektu.
-c

97. Jak działa wzorzec "Visitor"?
a. Visitor definiuje nową operację dla jednego typu obiektu, przyjmuje Element jako parametr i wykonuje na nim tę operację.
b. Visitor definiuje nową operację dla jednego typu obiektu, a Element przyjmuje obiekt Visitor, który wykonuje na nim operację.
c. Visitor definiuje nową operację dla każdego typu obiektu, a Element przyjmuje obiekt Visitor, który wykonuje na nim operację.
d. Visitor definiuje nową operację dla każdego typu obiektu, a Element przyjmuje obiekt Visitor i deleguje do niego operację.
-c

98. Jak zaimplementować wzorzec "Adapter"?
a. Przez stworzenie klasy implementującej wszystkie potrzebne interfejsy i delegującej poszczególne żądania do właściwych odbiorców.
b. Przez udostępnienie pojedynczej metody, która w zależności od parametru będzie delegować żądania do odpowiednich metod obiektu docelowego.
c. Przez dodanie wymaganych przez docelowy interfejs metod do klasy, której interfejs chcemy dostosować.
d. Przez stworzenie klasy implementującej docelowy interfejs i delegującej operacje do obiektu, którego interfejs chcemy dostosować.
-d

99. Jak zaimplementować wzorzec "Iterator"?
a. Kolekcja powinna udostępniać metodę przyjmującą obiekt Iterator, który będzie odpowiedzialny za wykonanie operacji na elementach kolekcji.
b. Kolekcja powinna udostępniać metody pozwalające na sprawdzenie liczby elementów i pobranie elementu o podanym indeksie.
c. Kolekcja powinna udostępniać metody pozwalające na pobranie następnego elementu i sprawdzenie czy kolejny element istnieje.
d. Kolekcja powinna udostępniać metodę zwracającą obiekt Iterator, który będzie odpowiedzialny za iterację po elementach kolekcji.
-d

100. Jak zaimplementować wzorzec "Observer"?
a. Obiekt obserwowany przechowuje listę obserwatorów i informuje je o zmianach stanu.
b. Obserwator i obiekt obserwowany komunikują się bezpośrednio peer-to-peer.
c. Obserwator i obiekt obserwowany komunikują się przez warstwę pośredniczącą.
d. Obserwator przechowuje listę obiektów obserwowanych i cyklicznie sprawdza ich stan.
-a

101. Jakie problemy może powodować nieprawidłowa implementacja wzorca "Singleton" w aplikacjach wielowątkowych?
a. Singleton nie działa w aplikacjach wielowątkowych.
b. Może prowadzić do utworzenia wielu instancji Singletona w różnych wątkach.
c. Może prowadzić do utworzenia jednej instancji Singletona w różnych wątkach.
d. Może prowadzić do przedwczesnego zakończenia wątków, które próbują uzyskać dostęp do Singletona.
-b

102. Jakie są wady stosowania wzorca "Visitor"?
a. Dodawanie nowych rodzajów elementów jest trudne, gdyż wymaga modyfikacji wszystkich Visitorów.
b. Visitor realizuje wiele zadań, co narusza zasadę jednej odpowiedzialności.
c. Modyfikacja pojedynczej operacji wymaga zmiany wszystkic Visitorów co narusza zasadę otwarte/zaamknięte.
d. Dodawanie nowych operacji jest trudne, gdyż wymaga modyfikacji wszystkich rodzajów elementów.
-a

103. Jakie są potencjalne problemy związane z używaniem wzorca "Abstract Factory"?
a. Tworzone przez fabrykę produkty mogą nie być ze sobą kompatybilne.
b. Tworzone przez fabrykę produkty mogą nie być poprawnie zainicjalizowane.
c. Dodanie nowej rodziny produktów wymaga modyfikacji wszystkich już istniejących rodzin.
d. Dodanie nowych rodzajów produktów wymaga modyfikacji wszystkich fabryk.
-d

104. Jakie są wady stosowania wzorca "Composite"?
a. Composite nie pozwala na użycie różnych typów liści w jednej strukturze.
b. Composite nie daje narzędzi do ograniczenia typu lub liczby obiektów tworzących strukturę.
c. Composite nie pozwala na użycie różnych typów kompozytów w jednej strukturze.
d. Composite wymaga określenia z góry maksymalnej głebokości drzewa.
-b

105. Czym jest wzorzec projektowy "Strategy"?
a. Strategy to wzorzec projektowy defeiniujący reguły wyboru właściwych odbiorców żądań oraz sposobu ich realizacji.
b. Strategy to wzorzec projektowy pozwalający na definiowanie rodzin algorytmów, które można wymieniać w czasie działania aplikacji.
c. Strategy to wzorzec projektowy definiujący szkielet algorytmu, którego szczegóły implementacji można modyfikować w klasach pochodnych.
d. Strategy to wzorzec projektowy pozwalający na definiowanie nowych algorytmów z operacji podstawowych w czasie działania aplikacji.
-b

106. Jakie są różnice między Proxy a Adapterem?
a. Za Proxy może kryć się wiele współpracujących obiektów, podczas gdy Adapter korzysta tylko z jednego.
b. Adapter może zmienić działanie obiektu, podczas gdy Proxy w ogóle nie wpływa na funkcjonalność.
c. Proxy zawsze dziedziczy po rzeczywistym obiekcie, podczas gdy Adapter zastępuje go.
d. Proxy kontroluje dostęp do obiektu, podczas gdy Adapter zmienia interfejs obiektu w celu jego dopasowania do innego.
-d

107. Jakie są główne cele stosowania wzorca "Factory Method"?
a. Zagwarantowanie unikalności tworzonych obiektów poprzez kontrolę procesu ich tworzenia.
b. Zapewnienie elastyczności w tworzeniu obiektów bez bezpośredniego odwoływania się do ich klas.
c. Przyśpieszenie procesu tworzenia obiektów poprzez zastąpienie konstruktorów metodami fabrycznymi.
d. Odroczenie czasu tworzenia obiektów do momentu, gdy są one faktycznie potrzebne.
-b

108. Jakie są główne cele stosowania wzorca "Abstract Factory"?
a. Zapewnienie, że obiekty tworzone przez fabryki będą prawidłowo zainicjalizowane.
b. Zapewnienie optymalnego zarządzania zasobami w aplikacji.
c. Zapewnienie, że obiekty tworzone przez fabryki będą poprawnie usuwane.
d. Zapewnienie zgodności między obiektami tworzonymi przez różne fabryki.
-d

109. Czym jest wzorzec projektowy "Prototype"?
a. Prototype to wzorzec projektowy, który umożliwia tworzenie zastępników obiektów, gdy ich klasy nie są jeszcze określone.
b. Prototype to wzorzec projektowy pozwalający na wybór strategii działania obiektu w zależności od kontekstu.
c. Prototype to wzorzec projektowy definiujący szkielet algorytmu, pozwalający na zmianę poszczególnych kroków.
d. Prototype to wzorzec projektowy, który umożliwia klonowanie obiektów, zamiast tworzenia ich od podstaw.
-d

Iteratory jakiej kategorii zapewniają adaptery w STL C++ ?
Wybierz jedną odpowiedź:
-a. nie zapewniają żadnych iteratorów
b. dwukierunkowe (bidirectional)
c. takie, jak kontener, który adaptują
d. o dostępie bezpośrednim (random access)

Iteratory jakiej kategorii zapewniają kolejki o dwóch końcach (deque) w STL C++ ?
Wybierz jedną odpowiedź:
a. jednokierunkowe (forward)
-b. o dostępie bezpośrednim (random access)
c. dwukierunkowe (bidirectional)
d. wejściowe (input)

Iteratory jakiej kategorii zapewniają wektory w STL C++ ?
Wybierz jedną odpowiedź:
a. dwukierunkowe (bidirectional)
-b. o dostępie bezpośrednim (random access)
c. jednokierunkowe (forward)
d. wejściowe (input)

Iteratory jakiej kategorii zapewniają listy w STL C++ ?
Wybierz jedną odpowiedź:
a. o dostępie bezpośrednim (random access)
b. jednokierunkowe (forward)
c. wyjściowe (output)
-d. dwukierunkowe (bidirectional)

Iteratory jakiej kategorii zapewniają mapy w STL C++ ?
Wybierz jedną odpowiedź:
a. jednokierunkowe (forward)
b. wyjściowe (output)
-c. dwukierunkowe (bidirectional)
d. o dostępie bezpośrednim (random access)

Jaka jest rola alokatorów w STL C++ ?
Wybierz jedną odpowiedź:
a. pozwalają dynamicznie alokować pamięć dla algorytmów, przez co można zwiększać i zmniejszać ich rozmiar kontenerów, na których operują
-b. pośredniczą w pracy kontenerów z pamięcią
c. jedynie za ich pośrednictwem klient może rezerwować pamięć dla kontenerów
d. zapewniają mechanizm odśmiecania pamięci (garbage collection), którego brak jest w "czystym" C++

Co to jest predykat (w STL C++) ?
Wybierz jedną odpowiedź:
a. obiekt funkcyjny, który nie pobiera parametrów
b. kontener, który przechowuje wartości logiczne (true i false)
-c. obiekt funkcyjny, który zwraca jako wynik wartość logiczną
d. obiekt funkcyjny, który pobiera jako parametry wartości logiczne

W jaki sposób algorytmy STL C++ dodają nowe elementy do kontenerów ?
Wybierz jedną odpowiedź:
a. operując na niskopoziomowych wskaźnikach do kontenerów
b. zapisując kontener do pliku, a po dodaniu elementów do pliku – wczytując kontener z tego pliku
c. przekształcają kontener na tablicę, a po dodaniu elementów do pliku – na odwrót
-d. poprzez przekazanie do nich iteratorów – wstawiaczy

Jakie kontenery STL C++ wspierają indeksowanie (operator [ ]) ?
Wybierz jedną odpowiedź:
a. listy, wektory i mapy
-b. kolejki o dwóch końcach, mapy i wektory
c. kolejki o dwóch końcach, listy i wektory
d. mapy, wektory i listy

Jaka jest rola kontenerów w bibliotece C++ STL ?
Wybierz jedną odpowiedź:
-a. przechowują zmienne różnych typów
b. przechowują obiekty śmiecie i zapewniają mechanizm odśmiecania (garbage collection), którego brak jest w "czystym" C++
c. przechowują wszystkie obiekty stworzone w programie i udostępniają je metodom programu
d. przechowują wskaźniki na metody, które pozwalają skorzystać z metod wirtualnych, których normalnie nie obsługuje STL

Jaka jest rola obiektów funkcyjnych w STL C++ ?
Wybierz jedną odpowiedź:
a. zmieniają metodę wirtualną w niewirtualną
-b. zmieniają działanie algorytmów i kontenerów
c. zmieniają metodę niewirtualna w wirtualną
d. pozwalają na wywołanie prywatnych i chronionych funkcji

Jakiego mechanizmu języka C++ używa biblioteka STL C++ aby zapewnić generyczność (obsługę dowolnych typów danych) algorytmów i kontenerów ?
Wybierz jedną odpowiedź:
a. klas abstrakcyjnych i metod wirtualnych
b. biblioteka nie zapewnia generycznych algorytmów i kontenerów
-c. szablonów
d. kompozycji i delegacji

Co to jest zbiór (set) STL C++ ?
Wybierz jedną odpowiedź:
-a. kolekcja posortowanych wartości
b. inna nazwa wektora
c. kolekcja par (klucz+wartość)
d. inna nazwa listy

Na czym polega wiązanie argumentów obiektów funkcyjnych w STL C++ ?
Wybierz jedną odpowiedź:
a. na ustaleniu ich wartości
b. na zamianie wartości funktorów 2-argumentowych
-c. na ustaleniu wartości jednego argumentu, przez co funktor 2-argumentowy zmienia się funktor 1-argumentowy
d. na opakowaniu argumentów typów prostych w kopertowe typy obiektowe

Jaka jest złożoność dostępu do dowolnego elementu (random access) w mapach (wg klucza) i zbiorach STL C++ ?
Wybierz jedną odpowiedź:
-a. logarytmiczna
b. kwadratowa
c. stała
d. liniowa

W jaki sposób algorytmy STL C++ „zmieniają” strukturę kontenerów, na których operują ?
Wybierz jedną odpowiedź:
a. przekształcają kontener na tablicę, a po modyfikacji struktury – na odwrót
b. zapisując je do pliku, modyfikując plik, a potem wczytując kontener z tego pliku
c. operując na niskopoziomowych wskaźnikach do kontenerów
-d. pobierając dodatkowy parametr – iterator i zapisując zmodyfikowaną wersję kontenera do niego

Jaka jest złożoność wstawienia (usunięcia) elementu na początku i końcu kolejki o dwóch końcach (deque) STL C++ ?
Wybierz jedną odpowiedź:
a. kwadratowa
b. logarytmiczna
c. liniowa
-d. stała

Jaka jest złożoność wstawienia (usunięcia) elementu do (z) mapy i zbioruSTL C++ ?
Wybierz jedną odpowiedź:
a. liniowa
-b. logarytmiczna
c. stała
d. kwadratowa

W jaki sposób algorytmy STL C++ „usuwają” elementy z kontenerów, na których operują ?
Wybierz jedną odpowiedź:
a. operując na niskopoziomowych wskaźnikach do kontenerów
-b. przesuwając elementy do usunięcia na koniec kontenera i zwracając iterator do pierwszego z nich
c. przekształcają kontener na tablicę, a po usunięciu elementów z pliku – na odwrót
d. zapisując kontener do pliku, a po wymazaniu elementów z pliku – wczytując kontener z tego pliku

Jaka jest złożoność wstawienia (usunięcia) elementu do (z) listy STL C++ (znając iterator do pozycji) ?
Wybierz jedną odpowiedź:
a. liniowa
b. logarytmiczna
c. kwadratowa
-d. stała

Czy algorytmy modyfikujące STL C++ mogą zmieniać wartości elementów w kontenerach, na których operują ?
Wybierz jedną odpowiedź:
a. mogą modyfikować typy obiektowe ale nie mogą modyfikować typów prostych
b. nie
-c. tak
d. mogą modyfikować typy proste ale nie mogą modyfikować typów obiektowych

Jaka jest złożoność dostępu do dowolnego elementu (random access) w mapach STL C++ wg wartości ?
Wybierz jedną odpowiedź:
a. stała
b. kwadratowa
c. logarytmiczna
-d. liniowa

Jaka jest złożoność wstawienia (usunięcia) elementu do (z) wektora STL C++ ?
Wybierz jedną odpowiedź:
a. logarytmiczna
b. kwadratowa
c. stała
-d. liniowa

Jaka jest rola adapterów w STL C++ ?
Wybierz jedną odpowiedź:
a. zmieniają interfejs iteratorów, tworząc iteratory odwrotne
b. zmieniają interfejs obiektów funkcyjnych, tworząc z funktorów 2-argumentowych – 1-argumentowe
-c. zmieniają interfejs kontenerów, tworząc kontenery o nowych funkcjonalnościach
d. zmieniają interfejs alokatorów, tworząc nowe modele pracy z pamięcią

Na czym operują algorytmy STL C++ ?
Wybierz jedną odpowiedź:
-a. na iteratorach
b. na adapterach kontenerów
c. na tablicach
d. na kontenerach

Czym są obiekty funkcyjne w STL C++ ?
Wybierz jedną odpowiedź:
-a. to obiekty, które „udają” funkcje
b. to funkcje, które „udają” obiekty
c. to obiekty, które posiadają co najmniej jedną metodę wirtualną
d. to klasy, z których można tworzyć i obiekty, i funkcje

Co to jest mapa (map) STL C++ ?
Wybierz jedną odpowiedź:
a. kolekcja kluczy
b. kolekcja wartości
-c. kolekcja par (klucz+wartość)
d. inna nazwa wektora

Jaka jest złożoność dostępu do dowolnego elementu (random access) w kolejkach o dwóch końcach (deque) STL C++ ?
Wybierz jedną odpowiedź:
a. kwadratowa (lub bliska jej)
b. liniowa (lub bliska jej)
c. logarytmiczna (lub bliska jej)
-d. stała (lub bliska jej)

Jaka jest rola iteratorów w STL C++ ?
Wybierz jedną odpowiedź:
a. umożliwiają bezpośredni dostęp do pamięci wirtualnej
b. przechowują generyczne dane
c. modyfikują działanie algorytmów przez zmianę kontenerów, na których operują
-d. za ich pośrednictwem algorytmy pracują na kontenerach

Jaka jest złożoność dostępu do dowolnego elementu (random access) w wektorach STL C++ ?
Wybierz jedną odpowiedź:
a. kwadratowa
-b. stała
c. logarytmiczna
d. liniowa

Czy algorytmy modyfikujące STL C++ mogą zmieniać strukturę kontenerów (dodawać nowe elementy i usuwać elementy istniejące), na których operują ?
Wybierz jedną odpowiedź:
-a. nie
b. mogą dodawać nowe elementy, ale nie mogą usuwać elementów
c. mogą usuwać elementy ale nie mogą dodawać nowych
d. tak

Jaka jest złożoność wstawienia (usunięcia) elementu na (z) dowolnej pozycji kolejki o dwóch końcach (deque) STL C++ ?
Wybierz jedną odpowiedź:
a. logarytmiczna
b. kwadratowa
-c. liniowa
d. stała

Jaka jest złożoność dostępu do dowolnego elementu (random access) w listach STL C++ ?
Wybierz jedną odpowiedź:
a. kwadratowa
b. logarytmiczna
c. stała
-d. liniowa

Czy algorytmy niemodyfikujące STL C++ naprawdę nie modyfikują kontenerów, na których działają ?
Wybierz jedną odpowiedź:
a. nie modyfikują wektorów, ale mogą modyfikować listy (tańszy koszt dostępu)
b. mogą modyfikować oryginalne kontenery
c. mogą „modyfikować” kontenery, ale tak naprawdę tworzą wtedy kopię i modyfikują kopię
-d. naprawdę nie modyfikują

Dlaczego biblioteka STL C++ praktycznie nie używa metod wirtualnych ?
Wybierz jedną odpowiedź:
a. ponieważ w C++ nie ma metod wirtualnych - pojawiają się dopiero w Javie i C
b. to nieprawda, używa ona bardzo często metod wirtualnych
-c. ponieważ są wolniejsze niż niewirtualne
d. ponieważ nie ma takiej potrzeby - biblioteka nie oferuje kontenerów i algorytmów generycznych (uniwersalnych, działających na dowolnych typach danych)

Kiedy stosujemy wzorzec architekturalny Warstwy (Layers) ?
Wybierz jedną odpowiedź:
a. kiedy chcemy umieścić komponenty systemu w różnych miejscach (warstwach) pamięci
b. kiedy tworzymy mały, kompaktowy system chcemy przyspieszyć jego działanie
c. kiedy tworzymy dość specyficzny, unikalny system i nie zależy nam, aby jego komponenty były uniwersalne (zdolne do wielokrotnego używania)
-d. kiedy tworzymy dość złożony system i chcemy podzielić jego klasy na pewne komponenty wg ich poziomu abstrakcji

Co jest główną ideą wzorca architekturalnego Warstwy (Layers) ?
Wybierz jedną odpowiedź:
a. stosowanie jak najczęściej kompozycji zamiast dziedziczenia
b. ujednolicenie interfejsu obiektów umieszczonych w różnych warstwach, na który podzieliliśmy system
-c. podział klas systemu na warstwy wg ich poziomów abstrakcji
d. stosowanie namiastek obiektów zdalnych (umieszczonych w różnych warstwach)

Czy warstwy w obiekcie zbudowanym wg wzorca Warstwy (Layers) można wymieniać ?
Wybierz jedną odpowiedź:
a. nie, w żadnym wypadku
-b. tak, na inne warstwy o tym samym interfejsie
c. tak, na dowolne inne warstwy
d. nie, chyba że system składa się tylko z 2 warstw

W typowym systemie opartym na klasycznej wersji wzorca architekturalnego Warstwy (Layers) jaka jest zależność między warstwami ?
Wybierz jedną odpowiedź:
-a. warstwa wyższa korzysta w swoim działaniu z warstwy bezpośrednio niższej
b. warstwa niższa korzysta w swoim działaniu z warstwy bezpośrednio wyższej
c. warstwa wyższa korzysta w swoim działaniu ze wszystkich warstw niższych
d. warstwa niższa korzysta w swoim działaniu ze wszystkich innych warstw

Na czym polega model komunikacji Polecenie z „keszowaniem” we wzorcu architekturalnym Warstwy (Layers) ?
Wybierz jedną odpowiedź:
-a. na wykonaniu polecenia warstwy najwyższej przez warstwę pośrednią, bez korzystania z usług warstwy najniższej
b. na wykonaniu polecenia warstwy najniższej przez warstwę pośrednią, bez korzystania z usług warstwy najwyższej
c. na zapamiętaniu wyniku zlecenia w warstwie najwyższej
d. na zapamiętaniu wyniku zlecenia w warstwie najniższej

Jaki jest kierunek komunikacji w modelu Zlecenie (top-down) we wzorcu architekturalnym Warstwy (Layers) ?
Wybierz jedną odpowiedź:
a. kaskadowe wywołanie metod od warstwy najniższej, przez wszystkie warstwy, do warstwy najwyższej; zwracanie wyniku w odwrotnym kierunku
b. kaskadowe wywołanie metod od warstwy najniższej, przez wszystkie warstwy, do warstwy najwyższej; zwracanie wyniku w tym samym kierunku
c. kaskadowe wywołanie metod od warstwy najwyższej, przez wszystkie warstwy, do warstwy najniższej; zwracanie wyniku w tym samym kierunku
-d. kaskadowe wywołanie metod od warstwy najwyższej, przez wszystkie warstwy, do warstwy najniższej; zwracanie wyniku w odwrotnym kierunku kierunku

Na czym polega model komunikacji Powiadomienie z filtrowaniem we wzorcu architekturalnym Warstwy (Layers) ?
Wybierz jedną odpowiedź:
-a. na zatrzymaniu powiadomienia na poziomie warstwy pośredniej, zanim dotrze ono do warstwy najwyższej
b. na wykorzystaniu wzorca Pośrednik (Proxy) ochronny
c. na przekazaniu notyfikacji do warstwy najwyższej
d. na zatrzymaniu powiadomienia na poziomie warstwy pośredniej, zanim dotrze ono do warstwy najniższej

Jaki jest kierunek komunikacji w modelu Powiadomienie (notyfikacja bottom-top) we wzorcu architekturalnym Warstwy (Layers) ?
Wybierz jedną odpowiedź:
-a. kaskadowe wywołanie metod od warstwy najniższej, przez wszystkie warstwy, do warstwy najwyższej; bez zwracania wyniku
b. kaskadowe wywołanie metod od warstwy najwyższej, przez wszystkie warstwy, do warstwy najniższej; zwracanie wyniku w odwrotnym kierunku kierunku
c. kaskadowe wywołanie metod od warstwy najniższej, przez wszystkie warstwy, do warstwy najwyższej; zwracanie wyniku w odwrotnym kierunku
d. kaskadowe wywołanie metod od warstwy najwyższej, przez wszystkie warstwy, do warstwy najniższej; bez zwracania wyniku


Na czym polega strategia push we wzorcu architekturalnym Potoki i Filtry (Pipes and Filters) ?
Wybierz jedną odpowiedź:
a. klient inicjuje przetwarzanie informacji przez system wywołując operację 'read' z ujścia danych
b. klient inicjuje przetwarzanie informacji przez system wywołując operację 'write' z ujścia danych
c. klient inicjuje przetwarzanie informacji przez system wywołując operację 'read' ze żródła danych
-d. klient inicjuje przetwarzanie informacji przez system wywołując operację 'write' ze źródła danych

Na czym polega strategia pull we wzorcu architekturalnym Potoki i Filtry (Pipes and Filters) ?
Wybierz jedną odpowiedź:
a. klient inicjuje przetwarzanie informacji przez system wywołując operację 'read' ze żródła danych
-b. klient inicjuje przetwarzanie informacji przez system wywołując operację 'read' z ujścia danych
c. klient inicjuje przetwarzanie informacji przez system wywołując operację 'write' z ujścia danych
d. klient inicjuje przetwarzanie informacji przez system wywołując operację 'read' ze źródła danych

Jaka jest rola potoków we wzorcu architekturalnym Potoki i Filtry (Pipes and Filters) ?
Wybierz jedną odpowiedź:
a. regulują prędkość „konsumowania” danych przez ujścia danych
-b. łączą ze sobą filtry przetwarzające przepływające przez nie dane (czasem je buforując)
c. regulują prędkość wytwarzania danych przez źródła danych
d. pobierają dane ze źródeł i przesyłają je w niezmienionej formie do wybranych ujść

Jaka jest rola filtrów we wzorcu architekturalnym Potoki i Filtry (Pipes and Filters) ?
Wybierz jedną odpowiedź:
a. filtrują przepływające przez nie dane (nie przepuszczając niektórych dalej)
-b. przetwarzają przepływające przez nie dane
c. pobierają dane ze źródeł i przesyłają je w niezmienionej formie do wybranych ujść
d. łączą ze sobą potoki przetwarzające przepływające przez nie dane

Do budowy jakich systemów stosujemy wzorzec architekturalny Potoki i Filtry (Pipes and Filters) ?
Wybierz jedną odpowiedź:
a. do prostych i kompaktowych systemów, aby przyspieszyć ich działanie przez zastosowanie potoków
-b. do systemów, w których kolejne, różne komponenty przetwarzają potokowe ten sam strumień danych
c. do systemów, w których takie same komponenty przetwarzają różne dane odebrane z różnych potoków
d. do systemów, w którym poszczególne komponenty nie komunikują się ze sobą

Co to są aktywne filtry we wzorcu architekturalnym Potoki i Filtry (Pipes and Filters) ?
Wybierz jedną odpowiedź:
-a. filtry, który w nieskończonej pętli w osobnych wątkach odczytują dane z lewego (poprzedzającego) potoku, przetwarzają je i zapisują do prawego (następującego) potoku
b. filtry, które w nieskończonej pętli w jednym wspólnym dla wszystkich filtrów wątku odczytują dane z lewego (poprzedzającego) potoku, przetwarzają je i zapisują do prawego (następującego) potoku
c. filtry, które w nieskończonej pętli w osobnych wątkach odczytują dane ze źródła, przetwarzają je i zapisują do ujścia
d. filtry, które potrafią wymusić na źródle wyprodukowanie danych


Jaka jest rola komponentu-eksperta we wzorcu architekturalnym Tablica rozwiązań (Blackboard) ?
Wybierz jedną odpowiedź:
a. tworzy algorytm, który potem zastosowany do danych wejściowych znajdzie finalne rozwiązanie
b. równolegle z innymi ekspertami przetwarza swoją część danych wyjściowych, produkując część finalnego rozwiązania
c. nie pozwala systemowi wyprodukować złego rozwiązania (wszystkie podejrzane rozwiązania są natychmiast odrzucanie, przez co mamy gwarancję, że system zadziała poprawnie)
-d. przetwarza dane z tablicy rozwiązań, ale wyniki tego przetwarzania nie muszą (choć mogą) być użyteczne do znalezienia końcowego rozwiązania, poprawne, kompletne, najlepsze

Kiedy stosujemy wzorzec architekturalny Tablica rozwiązań (Blackboard) ?
Wybierz jedną odpowiedź:
a. kiedy tworzymy prosty system o znanym algorytmie działania, który jednak może mieć wiele implementacji
b. kiedy tworzymy system, który może wyprodukować wiele równorzędnych, dobrych, konkurencyjnych rozwiązań umieszczanych w tablicy rozwiązań, z której klient wybiera jedno
-c. kiedy tworzymy system, który rozwiązuje złożone problemy korzystając z pracy komponentówe-ekspertów „zgromadzonych” wokół tablicy z różnymi obserwacjami, wynikami pośrednimi, alternatywnymi
d. kiedy do przechowywania danych (w tym rozwiązań) chcemy używać tablicy zamiast list


Czy klient i serwis w systemie opartym o wzorzec architekturalny Broker mogą być napisani w różnych językach programowania ?
Wybierz jedną odpowiedź:
-a. tak
b. tak, ale tylko takich, które kompilują się do tego samego kodu pośredniego (jak np. Java i Groovy, C
c. nie
d. tak, ale tylko tego samego producenta

Skąd Broker wie, gdzie odnaleźć obiekty-serwisy, którym musi przekazać żądanie klienta ?
Wybierz jedną odpowiedź:
a. pyta o to klienta, który przekazał żądanie
b. klient sam go o tym informuje
c. odpytuje cyklicznie wszystkie komputery w sieci lokalnej, i stąd zna wszystkie serwisy
-d. obiekty-serwisy rejestrują się w nim, i stąd zna wszystkie serwisy

Czemu służą pośrednicy strony klienta (client-side proxy) we wzorcu archiitekturalnym Broker ?
Wybierz jedną odpowiedź:
a. umożliwiają klientom rejestrowanie się w brokerze
b. komunikują klienta z serwisem bez pośrednictwa brokera
-c. reprezentują serwis po stronie klienta, tak, że klient nie musi zajmować się komunikacją przez sieć z serwisem (widzi go jako obiekt lokalny)
d. reprezentują klienta po stronie serwisu, tak, że serwis nie musi zajmować się komunikacją przez sieć ze swoim klientem (realizuje jego zlecenia jak lokalne wywołania metod)

Czemu służą pośrednicy strony serwisu-serwera (server-side proxy) we wzorcu archiitekturalnym Broker ?
Wybierz jedną odpowiedź:
a. reprezentują serwis po stronie klienta, tak, że klient nie musi zajmować się komunikacją przez sieć z serwisem (widzi go jako obiekt lokalny)
b. komunikują serwis z klientem bez pośrednictwa brokera
-c. reprezentują klienta po stronie serwisu, tak, że serwis nie musi zajmować się komunikacją przez sieć ze swoim klientem (realizuje jego zlecenia jak lokalne wywołania metod)
d. ukrywają wybrane funkcjonalności serwisu przez niektórymi serwisami

Na czym polega rejestracja serwisu w obiekcie Brokera ?
Wybierz jedną odpowiedź:
-?a. na wysłaniu brokerowi interfejsu serwisu i poinformowaniu go o adresie serwisu
b. na poinformowaniu brokera o adresie serwisu
-(bardziej to, bo na wykładzie nic nie ma o adresie serwisu)c. na wysłaniu brokerowi interfejsu serwisu
d. na wysłaniu brokerowi interfejsu serwisu oraz poinformowaniu go o adresie serwisu i języku, w jakim serwis został napisany (aby klient wiedział, czy może z niego skorzystać)

W jaki sposób w systemach zbudowanych wg wzorca architekturalnego Broker obiekt-klient wie, gdzie jest obiekt-serwis, z którego chce skorzystać ?
Wybierz jedną odpowiedź:
a. rejestruje się w brokerze, a gdy te się dowie, przekazuje mu tę informację
-b. nie musi tego wiedzieć – przekazuje zlecenie brokerowi
c. pyta o to obiekt brokera
d. odczytuje to sam z brokera – globalnej tablicy ze wskaźnikami obiektów

Kiedy stosuje wzorzec architekturalny Broker ?
Wybierz jedną odpowiedź:
-a. kiedy chcemy, aby system składał się z rozproszonych, komunikujących się ze sobą obiektów, które nie znają wzajemnie swoich położeń
b. kiedy dzielimy system na komponenty wg ich stopnia abstrakcji, i komponenty wyższego poziomu budują swoje funkcjonalności na komponentach niższego poziomu
c. kiedy chcemy, aby system składał się z rozproszonych, komunikujących się ze sobą obiektów, które znają wzajemnie swoje położenia
d. kiedy piszemy systemy wspierające pracę instytucji finansowych

Na czym polega wariant wzorca architekturalnego Broker o nazwie Direct Communication Broker System ?
Wybierz jedną odpowiedź:
a. na rezygnacji z pośrednika strony serwera – serwis musi sam nasłuchiwać w sieci na nadejście żądania
-b. klient jedynie uzyskuje od brokera adres serwisu, a następnie komunikuje się z nim bezpośrednio
c. klient przesyła brokerowi zlecenie i nie musi wiedzieć, gdzie jest serwis, który je wykona
d. na rezygnacji z pośrednika strony klienta – klient musi sam serializować parametry wywołania

Na czym polega wariant wzorca architekturalnego Broker o nazwie Message Passing Broker System ?
Wybierz jedną odpowiedź:
a. klient jedynie uzyskuje od brokera adres serwisu, a następnie komunikuje się z nim bezpośrednio
-b. klient wysyła jedynie dane (wiadomość), a serwis sam wie, jaką operację na nich wykonać
c. razem z danymi klient wysyła serwisowi kod operacji, który ten musi na nim wykonać
d. klient wysyła zlecenie serwisowi i nie spodziewa się żadnej odpowiedzi (wiadomość bez powrotu)

Wzorce architekturalne Refleksja i Mikrojądro służą do budowy systemów:
Wybierz jedną odpowiedź:
a. równoległych
b. rozproszonych
-c. adaptacyjnych
d. interaktywnych

Czym jest mikrojądro we wzorcu architekturalnym o tej samej nazwie (Microkernel) ?
Wybierz jedną odpowiedź:
a. to ograniczony zbiór zmiennych (pól), z którego mogą korzystać operacje systemu
-b. to ograniczony zbiór niezmiennych funkcjonalności bazowych, służących do realizacji zmieniających się funkcjonalności systemu oferowanych klientowi
c. to ograniczony zbiór klas, z których może skorzystać system
d. to ograniczony zbiór funkcjonalności systemu oferowanych klientowi wykorzystując liczne, zmieniające się dynamicznie funkcje bazowe (prywatne) systemu

Czym są serwery wewnętrzne we wzorcu architekturalnym Mikrojądro (Microkernel) ?
Wybierz jedną odpowiedź:
a. to zbiór klientów, którzy korzystają z systemu i są umieszczeni na tej samej maszynie co system
b. to maszyny, na których umieszczone są kopie systemu, aby zwiększyć jego niezawodność (są używane w razie awarii głównego serwera)
c. to moduły dynamicznie dołączane do systemu, które realizują zmieniające się funkcjonalności oferowane klientom
-d. to moduły dynamicznie dołączane do systemu, bezpośrednio operujące na zasobach na rzecz mikrojądra i izolujące od tych zasobów to mikrojądro

Czym są serwery zewnętrzne we wzorcu architekturalnym Mikrojądro (Microkernel) ?
Wybierz jedną odpowiedź:
-a. to moduły dynamicznie dołączane do systemu, które realizują zmieniające się funkcjonalności oferowane klientom
b. to zbiór klientów, którzy korzystają z systemu i są umieszczeni na innych niż system maszynach
c. to moduły dynamicznie dołączane do systemu, bezpośrednio operujące na zasobach na rzecz mikrojądra i izolujące od tych zasobów to mikrojądro
d. to maszyny, na których umieszczone są dane systemu, realizując technikę oddzielenia danych od kodu

Jaka jest rola adapterów we wzorcu architekturalnym Mikrojądro (Microkernel) ?
Wybierz jedną odpowiedź:
a. oferują mechanizm odnajdywania funkcjonalności systemu przez klientów (rodzaj usługi katalogowej)
b. pozwalają klientom na bezpośrednie korzystanie z ukrytych funkcjonalności mikrojądra
-c. oferują klientom zasadnicze funkcjonalności systemu (realizowane przez zewnętrzne serwery) pod ustalonym interfejsem
d. pozwalają klientom na bezpośrednie korzystanie z ukrytych funkcjonalności serwerów wewnętrznych

Kiedy stosujemy wzorzec architekturalny Mikrojądro (Microkernel) ?
Wybierz jedną odpowiedź:
-a. kiedy tworzymy system przewidziany na długie użytkowanie, którego funkcjonalności i zasoby, na których działa, mogą się zmieniać
b. kiedy tworzony system oferuje zbiór bazowych funkcjonalności, z których to sam klient „składa” bardziej złożone operacje
c. kiedy tworzony system ma być zoptymalizowany pamięciowo, aby można go było uruchamiać na urządzeniach z małymi zasobami
d. kiedy tworzymy system o nielicznych funkcjonalnościach, które nie będą się zmieniać

Kto morze korzystać z funkcjonalności mkirojądra we wzorcu architekturalnym o tej samej nazwie (Microkernel) ?
Wybierz jedną odpowiedź:
a. klienci systemu
b. wszystkie inne elementy systemu
-c. serwery zewnętrzne
d. serwery wewnętrzne


Metawarstwa we wzorcu architekturalnym Refleksja służy do:
Wybierz jedną odpowiedź:
a. przechowywania obiektów klas, które są używane przez system
-b. przechowywania kluczowych dla działania systemu danych, których zmiana zmienia działanie systemu
c. odpytywania o budowę klas (konstruktory, metody, pola) używanych przez system
d. przechowywania niezmiennych w trakcie działania systemu danych (rodzaj pamięci statycznej)

Kto może zmieniać dane zapisane w metawarstwie systemu zbudowanego wg wzorca architekturalnego Refleksja ?
Wybierz jedną odpowiedź:
a. każdy
-b. administrator systemu
c. klient systemu
d. nikt

Co jest główną ideą wzorca Refleksja ?
Wybierz jedną odpowiedź:
a. zastosowanie dynamicznego ładowania modułów do systemu, który dzięki temu może się łatwo zmieniać
b. wydzielenie trzech warstw systemu: logicznej, danych i prezentacji
-c. uzależnienie działania systemu od wydzielonej metawarstwy, której zmiana powoduje zmianę działania systemu
d. zastosowanie usług katalogowych, dzięki którym klient zawsze może odnaleźć szukany serwis


Wzorce architekturalne Model-Widok-Kontroler (MVC) i Prezentacja-Abstrakcja-Kontrola (PAC) służą do budowy systemów:
Wybierz jedną odpowiedź:
a. adaptacyjnych
b. rozproszonych
c. równoległych
-d. interaktywnych

Jaka jest rola kontrolera we wzorcu architekturalnym Model-Widok-Kontroler (MVC) ?
Wybierz jedną odpowiedź:
-a. pośredniczy w komunikacji systemu z użytkownikiem
b. komunikuje ze sobą różne elementy systemu (model i widok)
c. komunikuje się z innymi kontrolerami w systemie
d. kontroluje, kto ma prawo korzystać z funkcjonalności systemu

Jaka jest rola widoku we wzorcu architekturalnym Model-Widok-Kontroler (MVC) ?
Wybierz jedną odpowiedź:
a. pośredniczy w komunikacji systemu z użytkownikiem
-b. zapewnia funkcjonalność prezentacji danych modelu
c. pozwala klientowi uzyskać wgląd do wewnętrznych struktur systemu
d. zapewnia dostęp systemu do danych i realizacją funkcjonalności (logikę) systemu

Jaka jest rola modelu we wzorcu architekturalnym Model-Widok-Kontroler (MVC) ?
Wybierz jedną odpowiedź:
-a. zapewnia dostęp systemu do danych i realizacją funkcjonalności (logikę) systemu
b. pośredniczy w komunikacji systemu z użytkownikiem
c. modeluje działanie systemu wg wzoru matematycznego
d. definiuje modele wyświetlania danych przez system

Od czego zależny jest model we wzorcu architekturalnym Model-Widok-Kontroler (MVC) ?
Wybierz jedną odpowiedź:
a. od innych modeli zdefiniowanych w systemie
-b. pośrednio od widoku (powiadamia go o swoich zmianach wg wzorca Obserwator)
c. bezpośrednio od widoku (wywołuje jego publiczne metody)
d. bezpośrednio od kontrolera (wywołuje jego publiczne metody)

Czym różni się od wersji klasycznej wzorca architekturalnego Model-Widok-Kontroler (MVC) wariant stosowany w aplikacjach internetowych ?
Wybierz jedną odpowiedź:
-a. kontroler nie realizuje interakcji (myszka, klawiatura) z użytkownikiem i często realizuje logikę systemu
b. to nie model zapewnia dostęp do danych, tylko widok
c. model może mieć tylko jeden kontroler, a kontroler może mieć tylko jeden widok
d. model i widok są połączone w komponent zwany dokumentem (zwykle dokument HTML)


Jaka jest rola prezentacji we wzorcu architekturalnym Prezentacja-Abstrakcja-Kontrola (PAC) ?
Wybierz jedną odpowiedź:
a. łączy się z innymi prezentacjami w systemie
b. tylko komunikuje się z użytkownikiem systemu
-c. wyświetla dane i komunikuje się z użytkownikiem
d. tylko wyświetla dane systemu

Jaka jest rola abstrakcji we wzorcu architekturalnym Prezentacja-Abstrakcja-Kontrola (PAC) ?
Wybierz jedną odpowiedź:
-a. odpowiada za dostęp do danych i logikę systemu
b. wyświetla dane i komunikuje się z użytkownikiem
c. komunikuje się z innymi abstrakcjami w systemie
d. łączy ze sobą komponenty widoku i modelu systemu

Jaka jest rola kontroli we wzorcu architekturalnym Prezentacja-Abstrakcja-Kontrola (PAC) ?
Wybierz jedną odpowiedź:
a. zabezpiecza system przed niepowołanym dostępem poprzez listę ACL (Access Control List)
-b. komunikacja: między abstrakcją i prezentacją w agencie i z kontrolami innych agentów
c. komunikuje się z użytkownikiem systemu
d. pobiera dane z bazy danych i implementuje logikę danego agenta

W jaki sposób komunikują się abstrakcja i prezentacja danego agenta we wzorcu architekturalnym Prezentacja-Abstrakcja-Kontrola (PAC) ?
Wybierz jedną odpowiedź:
a. bezpośrednio ze sobą
-b. przez kontrolę tego agenta
c. przez mechanizm przerwać
d. przez kontrolę agenta najwyższego poziomu

Z jakim komponentem komunikuje się klient we wzorcu architekturalnym Prezentacja-Abstrakcja-Kontrola (PAC) ?
Wybierz jedną odpowiedź:
a. z abstrakcją agenta najwyższego poziomu
-b. ze wszystkimi prezentacjami (wszystkich agentów)
c. z kontrolą agenta najwyższego poziomu
d. ze wszystkimi kontrolerami (wszystkich agentów)

Co jest szkieletem systemu zbudowanym wg wzorca architekturalnego Prezentacja-Abstrakcja-Kontrola (PAC) ?
Wybierz jedną odpowiedź:
a. drzewo prezentacji
b. drzewo abstrakcji i prezentacji
c. drzewo abstrakcji
-d. drzewo kontroli

Kiedy zastosujemy wzorzec architekturalny Prezentacja-Abstrakcja-Kontrola (PAC) ?
Wybierz jedną odpowiedź:
a. kiedy tworzymy system obiektowy (złożony z obiektów-agentów) w języku nieobiektowym
b. kiedy tworzymy interaktywny system składający się z działających jednocześnie komponentów bez żadnej formy graficznej ani interakcji z użytkownikiem (demonów)
c. kiedy tworzymy system adaptacyjny
-d. kiedy tworzymy system składający się z wielu działających jednocześnie komponentów (agentów), z których każdy może mieć formę graficzną

Z ilu agentów może się składać system zbudowany wg wzorca architekturalnego Prezentacja-Abstrakcja-Kontrola (PAC) ?
Wybierz jedną odpowiedź:
a. z trzech (po jednym na każdy rodzaj komponenty)
-b. z wielu
c. z żadnego – agenci to klienci systemu
d. z jednego

Który agent w systemie zbudowanym wg wzorca architekturalnego Prezentacja-Abstrakcja-Kontrola (PAC) ma prawo mieć postać graficzną ?
Wybierz jedną odpowiedź:
a. tylko agenci poziomu najniższego
-b. wszyscy agenci
c. wszyscy agenci z wyjątkiem agentów pośrednich poziomów
d. tylko agent najwyższego poziomu

Czy jedna klasa może „uczestniczyć” (pełnić różne role) w kilku wzorcach w jednym programie ?
Wybierz jedną odpowiedź:
-a. tak, nawet jest to wskazane podnosząc zagęszczenie wzorców (pattern density)
b. nie, chyba że jest to klasa abstrakcyjne
c. tak, o ile będą to wzorce z jednej grupy
d. nie, gdyż zwiększyłoby to zagęszczenie wzorców (pattern density)

Rola w wzorcu to:
Wybierz jedną odpowiedź:
a. klasa bazowa dla wszystkich klas we wzorcu, definiująca zbiór podstawowych metod
b. inna nazwa wzorca
c. kontekst użycia tego wzorca
-d. propozycja klasy we wzorcu z zbiorem logicznie powiązanych funkcjonalności

Ile ról zdefiniowanych w jednym wzorcu może pełnić klasa w konkretnym zastosowaniu tego wzorca:
Wybierz jedną odpowiedź:
a. jedną
-b. wiele
c. żadnej
d. jedną lub dwie

Czy można użyć kilku wzorców projektowych w jednym programie ?
Wybierz jedną odpowiedź:
a. nie, jeden program to jeden wzorzec
b. tak, o ile będą to wzorce z jednej grupy
-c. tak
d. nie, chyba że godzimy się na znaczne spowolnienie programu

Które 2 pary opisują wzorce konkurencyjne (oferujące różna rozwiązania do tego samego problemu) ?
Wybierz jedną odpowiedź:
a. Abstrakcyjna Fabryka (Abstract Factory) i Metoda Fabrykująca (Factory Method) oraz Metoda Fabrykująca (Factory Method) i Metoda Szablonowa (Template Method)
b. Pyłek (Flyweight) i Kompozyt oraz Iterator i Gość (Visitor)
-c. Metoda Fabrykująca (Factory Method) i Prototyp oraz Strategia i Metoda Szablonowa (Template Method)
d. Adapter i Pośrednik (Proxy) oraz Budowniczy (Builder) i Singleton

Które wzorce są wzorcami złożonymi (wykorzystującymi do swojego działania inne wzorce) ?
Wybierz jedną odpowiedź:
a. Singleton i Memento
-b. Abstrakcyjna Fabryka (Abstract Factory) i Iterator Wewnętrzny (Abstract Factory zawiera kilka Factory Method; Iterator Wewnętrzny zawiera Polecenie)
c. Adapter i Pośrednik (Proxy)
d. Kompozyt i Pyłek (Flyweight)

Co to jest pattern story ?
Wybierz jedną odpowiedź:
a. sytuacja, kiedy budowa konkretnego systemu skończyła się porażką mimo poprawnego użycia wzorców projektowych
b. historia powstania danego wzorca
-c. historia zastosowania konkretnych wzorców projektowych do budowy konkretnego systemu
d. alternatywna nazwa danego wzorca

Co to jest zagęszczenie wzorców w programie (pattern density) ?
Wybierz jedną odpowiedź:
a. liczba klas w programie, które stanowią część jakiegoś wzorca
b. stosunek liczby klas w programie do liczby wzorców
-c. stosunek liczby wzorców w programie do liczby klas
d. liczba wzorców użytych w programie

Duże zagęszczenie wzorców w programie (pattern density) ?
Wybierz jedną odpowiedź:
-a. świadczy o dojrzałej i przemyślanej architekturze
b. jest niepożądane, gdyż komplikuje budowę programu
c. znacznie zwalnia działanie programu
d. znacznie przyspiesza działanie programu

Co to jest sekwencja wzorców (pattern sequence) ?
Wybierz jedną odpowiedź:
-a. powtarzający się w wielu procesach tworzenia konkretnych programów ciąg zastosowań tych samych wzorców
b. przepis na stworzenie gotowego programu przez zastosowanie kilku wzorców w zadanej kolejności
c. alfabetyczny spis wzorców użytych w danym systemie
d. alfabetyczny spis wszystkich znanych wzorów

Co to jest mapa wzorców ?
Wybierz jedną odpowiedź:
a. diagram klas danego systemu z zaznaczonymi użytymi wzorcami
b. graficzne zobrazowanie statystyki użycia poszczególnych wzorców (wskazuje te najbardziej popularne)
c. klasyfikacja wzorców do różnych grup, co pomaga w ich nauce
-d. powiązania, zależności między wzorcami ułatwiające ich wspólne, świadome użycie

Co to jest język wzorców (pattern language) ?
Wybierz jedną odpowiedź:
a. zbiór wszystkich nazw (podstawowych i alternatywnych, często w różnych językach) wzorców z danej dziedziny
b. dokładny opis powiązań i zależności między wzorcami, co ułatwia ich łączenie
-c. pomoc w tworzeniu przez projektanta architektury systemu przez proponowanie stosowania kolejnych (często alternatywnych) wzorców
d. „przepis” umożliwiający automatyczne (często maszynowe) stworzenie gotwej architektury systemu przez stosowanie kolejnych (czasem alternatywnych) wzorców

